package LeetCode.Templates;

//Основная идея
//Мы работаем с подмассивом фиксированной длины k ("окном")
//Вместо того чтобы каждый раз заново вычислять сумму
//(или другую характеристику) для нового подмассива, мы:
//"Добавляем" новый элемент (который вошёл в окно)
//"Удаляем" элемент, который вышел из окна

//Это позволяет переиспользовать предыдущие вычисления

public class FixeSlidingWindow {
    /**
     * Находит максимальную сумму подмассива фиксированного размера k
     * @param arr - входной массив чисел
     * @param k - размер окна
     * @return максимальная сумма подмассива длины k
     */
    public static int maxSumSubarray(int[] arr, int k) {
        // Проверка на валидность входных данных
        if (arr == null || arr.length == 0 || k <= 0 || k > arr.length) {
            throw new IllegalArgumentException("Некорректные входные данные");
        }

        // 1. Вычисляем сумму первого окна
        int windowSum = 0;
        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }

        // 2. Инициализируем максимальную сумму
        int maxSum = windowSum;

        // 3. Скользим окном по массиву
        for (int i = k; i < arr.length; i++) {
            // Добавляем новый элемент и убираем элемент, выходящий из окна
            windowSum += arr[i] - arr[i - k];
            // Обновляем максимальную сумму
            maxSum = Math.max(maxSum, windowSum);
        }

        return maxSum;
    }
}
